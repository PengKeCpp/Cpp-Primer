# 第十五章 面向对象程序设计

## 15.1 OOP：概述

对于某些函数希望它的派生类各自定义自己的版本，此时基类将这些函数声明成**虚函数**。

```cpp
class Quote {
public:
    std::string isbn() const;
    virtual double net_price(size_t n) const;
};
```

派生类必须通过**类派生列表**明确指出哪个基类继承而来，在C++11中派生类改写基类的虚函数时，可以在该函数的形参列表之后增加一个**override**关键字。

```cpp
class Bulk_quote ： public Quote{
public:
    double net_price(size_t )const override;
};
```

在C++语言中，当我们使用基类的引用或指针调用一个虚函数时将发生**动态绑定**，传入哪个对象调用哪个对象的函数。

```cpp
double print_total(ostream& os, const Quote &item, size_t n) {
	double ret = item.net_price(n);
    os << "ISBN: " << item.isbn()
       << " # sold：" << n << " total due: " << ret << endl;
    return ret;
}
```

## 15.2  定义基类和派生类

## 15.3  虚函数

1. 对虚函数的调用将在运行时才被解析
2. 通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本
3. 当且仅当通过**基类的指针或者引用**调用虚函数时, 才会在运行时解析该调用, 只有这种情况下才可能会静态类型和动态类型可能不同

**构成虚函数条件：**
1. 通过基类的指针或引用调用虚函数
2. 该虚函数的形参以及返回值对于基类和派生类必须严格匹配(例外情况：当类的虚函数的返回类型是类本身的指针或者引用)

**final和overried说明符:**
- overried说明符：让编译器为我们发现错误, 如果我们使用overried标记了某个函数, 在派生类中该函数并没有覆盖已存在的函数，编译器将报错
- final说明符：将某个虚函数指定为final, 之后尝试任何覆盖该函数的操作都将引发错误

**虚函数与默认实参：**
当基类和派生类中定义的默认实参不一样时, 通过基类的指针或引用调用该函数时, 传入一个派生类, 则实际该默认实参时基类的默认实参

```cpp
//example:
#include <iostream>

using namespace std;

class Base{
public:
    Base() = default;
    virtual void print_net(int num = 10) const {
        cout << "Base:" << endl;
        cout << num << endl;
    }
    virtual ~Base() {

    }
};

class Drived : public Base{
public:
    void print_net(int num = 20) const override {
        cout << "Drived:" << endl;
        cout << num << endl;
    }
};
void print_test(const Base& base) {
    base.print_net();
}
int main() {
    Drived drived;
    print_test(drived);
    return 0;
}
//output:
/*
Drived:
10
*/
```
**回避虚函数的机制：**
当我们希望对虚函数的调用不要进行动态绑定时, 而是强迫执行某个虚函数的特定版本, 使用作用域运算符可以实现

```cpp
double undiscounted = baseP->Quote::net_price(42);
```

如果一个派生类虚函数想要调用基类的版本, 但是没有使用作用域运算符, 则会发生无限递归

```cpp
#include <iostream>

using namespace std;

class Base{
public:
    Base() = default;
    virtual void print_net(int num = 10) const {
        cout << "Base:" << endl;
        cout << num << endl;
    }
    virtual ~Base() {

    }
};

class Drived : public Base{
public:
    void print_net(int num = 20) const override {
        print_net();    //should use code: Base::print_net();
    }
};
void print_test(const Base& base) {
    base.print_net();
}
int main() {
    Drived drived;
    print_test(drived);
    return 0;
}
```

## 15.4  抽象基类
**纯虚函数**
当在基类中只需要定义接口时, 而不需要对函数进行定义, 可以将函数声明为纯虚函数, 和普通函数不一样, 纯虚函数**无须定义**:

```cpp

class Disc_quote: public Quote{
public:
    Disc_quote() = default;
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc) : Quote(book,price),
               quantity(qty), discount(disc) {}
    double net_price(std::size_t) const = 0;
private:
    size_t quantity = 0;
    double discount = 0.0;
};

```

纯虚函数的特性:
1. 含有纯虚函数的类是一个抽象基类, 不能创建一个抽象基类
2. 派生类需要覆盖一个抽象基类, 不覆盖抽象基类那么派生类也是一个抽象基类, 这样派生类也不能定义

