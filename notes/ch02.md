# 第二章 变量和基本类型

## 2.1 基本内置类型



### 2.1.1 算术类型

#### 内置类型

+ 算术类型
  + 整型：包括字符、布尔、整型类型
  + 浮点型
+ 空类型

#### 内置类型的及其实现

可寻址的最小单元：**字节**

存储的基本单元：**字**

类型决定了数据所占的比特数以及该**如何解释**这些比特的内容。

#### 带符号和无符号类型

**带符号类型：**正数、负数、0

**无符号类型：**正数、0

char具体带符号或无符号**由编译器来决定。**

#### 算法类型

| 类型          | 含义           | 最小尺寸                       |
| ------------- | -------------- | ------------------------------ |
| `bool`        | 布尔类型       | 8bits                          |
| `char`        | 字符           | 8bits                          |
| `wchar_t`     | 宽字符         | 16bits                         |
| `char16_t`    | Unicode字符    | 16bits                         |
| `char32_t`    | Unicode字符    | 32bits                         |
| `short`       | 短整型         | 16bits                         |
| `int`         | 整型           | 16bits (在32位机器中是32bits)  |
| `long`        | 长整型         | 32bits                         |
| `long long`   | 长整型         | 64bits （是在C++11中新定义的） |
| `float`       | 单精度浮点数   | 6位有效数字                    |
| `double`      | 双精度浮点数   | 10位有效数字                   |
| `long double` | 扩展精度浮点数 | 10位有效数字                   |

#### 如何选择类型

- 1.当明确知晓数值不可能是负数时，选用无符号类型；
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 3.算术表达式中不要使用`char`或`bool`。
- 4.浮点运算选用`double`，单精度有时转化为双精度。



### 2.1.2 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。
- 浮点数赋给整数，结果值保留浮点数中小数点之前的部分。
- 整数赋给浮点数，**小数部分记为0。**
- 给无符号赋一个超出表示范围的值。(num+表示范围数的总个数)%表示范围数的总个数;
- 给带符号赋一个超出表示范围的值。结果未定义(程序可能继续工作、崩溃、生成垃圾数据)。



> **提示：切勿混用带符号数和无符号数。当表达式中既有带符号数又有无符号数。带符号数自动转换为无符号数。**



### 2.1.3字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。
  - 整型和浮点型字面值。
  
    - 整数(以0开头代表8进制，0x开头代表16进制)
    - 默认浮点型是**double**,用科学计数法，指数用E或e标识。
  
    
  
  - 字符和字符串字面值。
    - 使用空格连接，继承自C。
    - 字符字面值：单引号， `'a'`
    - 字符串字面值：双引号， `"Hello World""`
    - 每个字符串结尾处有一个空字符('\0')
    
  - 转义序列。
  
    - 程序员不能直接使用的:1.不可打印的字符。2.特殊含义的字符。要使用时用转义序列(以`\`开头)；
  
  - 布尔字面值。`true`，`false`。
  
  - 指针字面值。`nullptr`



## 2.2 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。   `C++`中**变量**和**对象**一般可以互换使用。



### 2.2.1 变量定义（define）

- **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
- **初始化**（initialize）：对象在创建时获得了一个特定的值。
  - **初始化 != 赋值**
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替



**列表初始化：**使用花括号`{}`，如`int units_sold{0};` 如果初始值存在丢失信息的风险，编译器将报错。

```c++
long double ld=3.1415926536;
int a{ld},b={ld};//转换未执行，存在对视信息的风险
```

**默认初始化：**

- 定义于函数体内的**内置对象**没有初始化，其值未定义。定义于函数体之外的变量初始化为0。
- 类对象没有显示初始化，其值由类确定。



> **提示：未初始化变量引发运行时故障。建议初始化每一个内置类型的变量。**



### 2.2.2 变量的**声明**（declaration） vs **定义**（define）

  - 为了支持分离式编译，`C++`将声明和定义区分开。**声明：**使得名字为程序所知。**定义：**负责创建与名字关联的实体。申请了存储空间。
  - **extern**：只是说明变量定义在其他地方。
  - 只声明而不定义： 在变量名前添加关键字 `extern`，如`extern int i;`。但如果包含了初始值，就变成了定义：`extern double pi = 3.14;`
  - 变量只能被定义一次，但是可以多次声明。
- 名字的**作用域**（namescope）



### 2.2.3 标识符

**C++的标识符**

- 由字母、数字、下划线组成。开头必须是字母或下画线。没有长度限制，大小写敏感。
- 不能连续出现两个下划线，不能以下画线紧连大写字母开头，在函数体外的不能以下画线开头。



## 2.3 复合类型



## 左值和右值

- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。



### 2.3.1 引用

**引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。**引用即别名。**

```c++
int ival=1024;
int &refVal = val;		//refVal指向ival(是ival的另一个名字)
```

引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。无法重新绑定因此引用必须初始化。

**引用必须初始化，引用不是对象**没有具体的地址。

定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。

**引用的定义：**除两种例外情况，引用的类型要和绑定对象的类型严格匹配。引用不能绑定到字面值或某个表达式的计算结果绑定在一起。

```c++
int &refVal=10;			//错误：引用类型的初始值必须是一个对象
double dval=3.14;
int &refVal2=dval;		//错误：类型不匹配。
```



### 2.3.2指针

- 是一种 `"指向（point to）"`另外一种类型的复合类型。
- 指针本身是**对象，**允许对指针赋值和拷贝，可以指向不同的对象，**无须在定义时初始化，在块作用域内**如果没有初始化其值将是不确定的 。
- **定义**指针类型： `int *ip1;`，**从右向左读**，`ip1`是指向`int`类型的指针。
- 指针存放某个对象的**地址**。
- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。
- 指针的值的四种状态：
  - 1.指向一个对象；
  - 2.指向紧邻对象的下一个位置；
  - 3.空指针；
  - 4.无效指针。
- 指针访问对象： `cout << *p;`， `*`是**解引用符**。
- 空指针不指向任何对象。
- `void*`指针可以存放**任意**对象的地址。但是不能直接操作void*指针所指的对象。
- 其他指针类型必须要与所指对象**严格匹配**。
- 两个指针相减的类型是`ptrdiff_t`。
- 建议：**初始化所有指针。**如果不清楚指向何处，就把它初始化为nullptr或者0。



### 2.3.3理解复合类型的声明

面对一条比较复杂的指针或引用的声明语句时，**从右向左阅读**有助于弄清楚它的真实含义。

```c++
int i=42;
int *p;			//p是一个int型的指针
int *&r=p;		//r是一个对指针p的引用
r=&i;			//r引用了一个指针，因此给r赋值&i就是令p指向i
*r=0;			//解引用r得到i,也就是p指向的对象，将i的值改为0
```



## 2.4 const限定符

**动机：**希望定义一些不能被改变值的变量。

因为const对像一旦创建后其值就不能再改变，所以**const对象必须初始化。**

```c++
const int i=get_size();		//正确：运行时初始化
const int j=42;				//正确：编译时初始化
const int k;				//错误：k是一个未经初始化的常量
```

**默认状态下，const对象仅再文件内有效。如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。不管声明还是定义都添加extern关键字。**

```c++
//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize=fcn();
//file_1.h头文件
extern const int bufSize;//与file_1.cc中定义的bufSize是同一个
```



### 2.4.1 const的引用

**reference to const**（对常量的引用）：指向const对象的引用，可以读取但不能修改`refVal`。

```c++
const int ci=1024;
const int &r1=ci;
r1=42;				//错误：r1是对常量的引用
int &r2=ci			//错误：试图让一个非常量引用指向一个常量对象
```

**对const的引用可能引用一个非const的对象，若对象可能是一个非常量，允许通过其他途径改变它的值。**

```cpp
int i=42;
int &r1=i;				//引用r1绑定对象i
const int &r2=i;		//r2也绑定对象i,但是不允许通过r2修改i的值
r1=0;					//r1并非常量,i的值修改为0
r2=0;					//错误:r2是一个常量引用
```

**初始化和对const的引用：**允许为一个常量引用绑定非常量的对象、字面值、一般表达式

```cpp
int i=42;
const int &r1=i;			
const int &r2=42;			//正确：r2是一个常量引用
const int &r3=r1*2;			//正确：r3是一个常量引用
int &r4=r1*2				//错误：r4是一个普通的非常量引用
```

**临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。

对临时量的引用是非法行为。



### 2.4.2 指针和const

**指向常量的指针**（pointer to const）：不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

```c++
const double pi=3.14;	//pi是个常量，它的值不能改变
double *ptr=&pi;		//错误：ptr是一个普通指针
const double *cptr=&pi;	//正确：cptr可以指向一个双精度常量
*cptr=42;				//错误：不能给*cptr赋值
```

**常量指针**（const pointer）：指针本身是常量，**必须初始化**，而且一旦初始化完成，其值就不能再改变。

```c++
int errNumb=0;
int *const currErr=&errNumb;//currErr将一直指向errNumb
```



### 2.4.3 顶层const

**顶层const**：指针本身是个常量。也可以表示**任意的对象是常量。**

**底层const**：指针指向的对象是个常量。与指针和引用等复合类型的基本类型部分有关。

```c++
int i=0;
int *const p1=&i;		//不能改变p1的值，这是一个顶层const
const int ci=42;		//不能改变ci的值，这是一个顶层const
const int *p2=&ci;		//允许改变p2的值，这是一个底层const
const int *const p3=p2;
const int &r=ci;		//用于声明引用的const都是底层const
```

**当执行拷贝操作时，底层const 不受什么影响。**

**对于顶层const：在拷入拷出时，必须具有相同的底层const资格，或者两个对象数据类型，必须能够相互转换。非常量可以转换成常量。**

```c++
int *p=p3;		//错误：p3包含底层const的定义，而p没有
p2=p3;			//正确：p2和p3都是底层const
p2=&i;			//正确：int*能转换成const int*
int &r=ci;		//错误：普通的int& 不能绑定到int常量上
const int &r2=i;//正确：const int& 可以绑定到普通int上
```



### 2.4.4`constexpr`和常量表达式

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。
- `C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。

## 处理类型

### 类型别名

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）

### auto类型说明符

- **auto**类型说明符：让编译器**自动推断类型**。
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，需要自己加`const`
- `C++11`

### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- 不会忽略`顶层const`。
- `C++11`

## 自定义数据结构

### struct

- 类可以以关键字`struct`开始，紧跟类名和类体。
- 类数据成员：类体定义类的成员。
- `C++11`：可以为类数据成员提供一个**类内初始值**（in-class initializer）。

### 编写自己的头文件

- 头文件通常包含哪些只能被定义一次的实体：类、`const`和`constexpr`变量。

预处理器概述：

- **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。
- 当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`
- **头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
strct Sale_data{
    ...
}
#endif
```