# 第二章 变量和基本类型

## 2.1 基本内置类型



### 2.1.1 算术类型

#### 内置类型

+ 算术类型
  + 整型：包括字符、布尔、整型类型
  + 浮点型
+ 空类型

#### 内置类型的及其实现

可寻址的最小单元：**字节**

存储的基本单元：**字**

类型决定了数据所占的比特数以及该**如何解释**这些比特的内容。

#### 带符号和无符号类型

**带符号类型：**正数、负数、0

**无符号类型：**正数、0

char具体带符号或无符号**由编译器来决定。**

#### 算法类型

| 类型          | 含义           | 最小尺寸                       |
| ------------- | -------------- | ------------------------------ |
| `bool`        | 布尔类型       | 8bits                          |
| `char`        | 字符           | 8bits                          |
| `wchar_t`     | 宽字符         | 16bits                         |
| `char16_t`    | Unicode字符    | 16bits                         |
| `char32_t`    | Unicode字符    | 32bits                         |
| `short`       | 短整型         | 16bits                         |
| `int`         | 整型           | 16bits (在32位机器中是32bits)  |
| `long`        | 长整型         | 32bits                         |
| `long long`   | 长整型         | 64bits （是在C++11中新定义的） |
| `float`       | 单精度浮点数   | 6位有效数字                    |
| `double`      | 双精度浮点数   | 10位有效数字                   |
| `long double` | 扩展精度浮点数 | 10位有效数字                   |

#### 如何选择类型

- 1.当明确知晓数值不可能是负数时，选用无符号类型；
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 3.算术表达式中不要使用`char`或`bool`。
- 4.浮点运算选用`double`，单精度有时转化为双精度。



### 2.1.2 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。
- 浮点数赋给整数，结果值保留浮点数中小数点之前的部分。
- 整数赋给浮点数，**小数部分记为0。**
- 给无符号赋一个超出表示范围的值。(num+表示范围数的总个数)%表示范围数的总个数;
- 给带符号赋一个超出表示范围的值。结果未定义(程序可能继续工作、崩溃、生成垃圾数据)。



> **提示：切勿混用带符号数和无符号数。当表达式中既有带符号数又有无符号数。带符号数自动转换为无符号数。**



### 2.1.3字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。
  - 整型和浮点型字面值。
  
    - 整数(以0开头代表8进制，0x开头代表16进制)
    - 默认浮点型是**double**,用科学计数法，指数用E或e标识。
  
    
  
  - 字符和字符串字面值。
    - 使用空格连接，继承自C。
    - 字符字面值：单引号， `'a'`
    - 字符串字面值：双引号， `"Hello World""`
    - 每个字符串结尾处有一个空字符('\0')
    
  - 转义序列。
  
    - 程序员不能直接使用的:1.不可打印的字符。2.特殊含义的字符。要使用时用转义序列(以`\`开头)；
  
  - 布尔字面值。`true`，`false`。
  
  - 指针字面值。`nullptr`



## 2.2 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。   `C++`中**变量**和**对象**一般可以互换使用。



### 2.2.1 变量定义（define）

- **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
- **初始化**（initialize）：对象在创建时获得了一个特定的值。
  - **初始化 != 赋值**
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替



**列表初始化：**使用花括号`{}`，如`int units_sold{0};` 如果初始值存在丢失信息的风险，编译器将报错。

```c++
long double ld=3.1415926536;
int a{ld},b={ld};//转换未执行，存在对视信息的风险
```

**默认初始化：**

- 定义于函数体内的**内置对象**没有初始化，其值未定义。定义于函数体之外的变量初始化为0。
- 类对象没有显示初始化，其值由类确定。



> **提示：未初始化变量引发运行时故障。建议初始化每一个内置类型的变量。**



### 2.2.2 变量的**声明**（declaration） vs **定义**（define）

  - 为了支持分离式编译，`C++`将声明和定义区分开。**声明：**使得名字为程序所知。**定义：**负责创建与名字关联的实体。申请了存储空间。
  - **extern**：只是说明变量定义在其他地方。
  - 只声明而不定义： 在变量名前添加关键字 `extern`，如`extern int i;`。但如果包含了初始值，就变成了定义：`extern double pi = 3.14;`
  - 变量只能被定义一次，但是可以多次声明。
- 名字的**作用域**（namescope）



### 2.2.3 标识符

**C++的标识符**

- 由字母、数字、下划线组成。开头必须是字母或下画线。没有长度限制，大小写敏感。
- 不能连续出现两个下划线，不能以下画线紧连大写字母开头，在函数体外的不能以下画线开头。



## 2.3 复合类型

### 左值和右值

- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。



### 2.3.1 引用

**引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。**引用即别名。**

```c++
int ival=1024;
int &refVal = val;		//refVal指向ival(是ival的另一个名字)
```

引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。无法重新绑定因此引用必须初始化。

**引用必须初始化，引用不是对象**没有具体的地址。

定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。

**引用的定义：**除两种例外情况，引用的类型要和绑定对象的类型严格匹配。引用不能绑定到字面值或某个表达式的计算结果绑定在一起。

```c++
int &refVal=10;			//错误：引用类型的初始值必须是一个对象
double dval=3.14;
int &refVal2=dval;		//错误：类型不匹配。
```



### 2.3.2指针

- 是一种 `"指向（point to）"`另外一种类型的复合类型。
- 指针本身是**对象，**允许对指针赋值和拷贝，可以指向不同的对象，**无须在定义时初始化，在块作用域内**如果没有初始化其值将是不确定的 。
- **定义**指针类型： `int *ip1;`，**从右向左读**，`ip1`是指向`int`类型的指针。
- 指针存放某个对象的**地址**。
- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。
- 指针的值的四种状态：
  - 1.指向一个对象；
  - 2.指向紧邻对象的下一个位置；
  - 3.空指针；
  - 4.无效指针。
- 指针访问对象： `cout << *p;`， `*`是**解引用符**。
- 空指针不指向任何对象。
- `void*`指针可以存放**任意**对象的地址。但是不能直接操作void*指针所指的对象。
- 其他指针类型必须要与所指对象**严格匹配**。
- 两个指针相减的类型是`ptrdiff_t`。
- 建议：**初始化所有指针。**如果不清楚指向何处，就把它初始化为nullptr或者0。



### 2.3.3理解复合类型的声明

面对一条比较复杂的指针或引用的声明语句时，**从右向左阅读**有助于弄清楚它的真实含义。

```c++
int i=42;
int *p;			//p是一个int型的指针
int *&r=p;		//r是一个对指针p的引用
r=&i;			//r引用了一个指针，因此给r赋值&i就是令p指向i
*r=0;			//解引用r得到i,也就是p指向的对象，将i的值改为0
```



## 2.4 const限定符

**动机：**希望定义一些不能被改变值的变量。

因为const对像一旦创建后其值就不能再改变，所以**const对象必须初始化。**

```c++
const int i=get_size();		//正确：运行时初始化
const int j=42;				//正确：编译时初始化
const int k;				//错误：k是一个未经初始化的常量
```

**默认状态下，const对象仅再文件内有效。如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。不管声明还是定义都添加extern关键字。**

```c++
//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize=fcn();
//file_1.h头文件
extern const int bufSize;//与file_1.cc中定义的bufSize是同一个
```



### 2.4.1 const的引用

**reference to const**（对常量的引用）：指向const对象的引用，可以读取但不能修改`refVal`。

```c++
const int ci=1024;
const int &r1=ci;
r1=42;				//错误：r1是对常量的引用
int &r2=ci			//错误：试图让一个非常量引用指向一个常量对象
```

**对const的引用可能引用一个非const的对象，若对象可能是一个非常量，允许通过其他途径改变它的值。**

```cpp
int i=42;
int &r1=i;				//引用r1绑定对象i
const int &r2=i;		//r2也绑定对象i,但是不允许通过r2修改i的值
r1=0;					//r1并非常量,i的值修改为0
r2=0;					//错误:r2是一个常量引用
```

**初始化和对const的引用：**允许为一个常量引用绑定非常量的对象、字面值、一般表达式

```cpp
int i=42;
const int &r1=i;			
const int &r2=42;			//正确：r2是一个常量引用
const int &r3=r1*2;			//正确：r3是一个常量引用
int &r4=r1*2				//错误：r4是一个普通的非常量引用
```

**临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。

对临时量的引用是非法行为。



### 2.4.2 指针和const

**指向常量的指针**（pointer to const）：不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

```c++
const double pi=3.14;	//pi是个常量，它的值不能改变
double *ptr=&pi;		//错误：ptr是一个普通指针
const double *cptr=&pi;	//正确：cptr可以指向一个双精度常量
*cptr=42;				//错误：不能给*cptr赋值
```

**常量指针**（const pointer）：指针本身是常量，**必须初始化**，而且一旦初始化完成，其值就不能再改变。

```c++
int errNumb=0;
int *const currErr=&errNumb;//currErr将一直指向errNumb
```



### 2.4.3 顶层const

**顶层const**：指针本身是个常量。也可以表示**任意的对象是常量。**

**底层const**：指针指向的对象是个常量。与指针和引用等复合类型的基本类型部分有关。

```c++
int i=0;
int *const p1=&i;		//不能改变p1的值，这是一个顶层const
const int ci=42;		//不能改变ci的值，这是一个顶层const
const int *p2=&ci;		//允许改变p2的值，这是一个底层const
const int *const p3=p2;
const int &r=ci;		//用于声明引用的const都是底层const
```

**当执行拷贝操作时，顶层const 不受什么影响。**

**对于底层const：在拷入拷出时，必须具有相同的底层const资格，或者两个对象数据类型，必须能够相互转换。非常量可以转换成常量。**

```c++
int *p=p3;		//错误：p3包含底层const的定义，而p没有
p2=p3;			//正确：p2和p3都是底层const
p2=&i;			//正确：int*能转换成const int*
int &r=ci;		//错误：普通的int& 不能绑定到int常量上
const int &r2=i;//正确：const int& 可以绑定到普通int上
```



### 2.4.4`constexpr`和常量表达式

**常量表达式：**指值不会改变，且在**编译过程中**就能得到计算结果的表达式。字面值是常量表达式，用常量表达式初始化的const对象是常量表达式。

```c++
const int max_files=20;//max_files是常量表达式
int staff_size=27;//staff_size不是常量表达式
const int sz=get_size();//sz不是常量表达式，在运行时才能获取值
```

**constexpr变量：**由编译器来验证表达式的值是否是一个常量表达式，所以constexptr的变量一定是常量。必须用常量表达式初始化。

```cpp
constexpr int mf=20;			//20是一个常量表达式
constexpr int limit=mf+1;		//mf+1是常量表达式
constexpr int sz=size();		//只有当size是一个constexpr函数时才是一条正确的语句
```

**字面值类型**

声明constexpr时用**字面值类型(简单、易见、容易得到)**

**字面值类型：**算术类型、引用、指针

**非字面值类型：**IO库、自定义类、string类型

指针定义成constexpr时，初始值必须是0或者nullptr或者存储对象的地址不变。**函数体之外**的对象地址不变，**函数体之内**的对象地址变化。

**指针和constexpr**

在constexpr中声明一个指针，限定符仅对指针有效，与指针所指对象无关，即使**顶层const**

```c++
constexpr int *np=nullptr;//np是指向整数的常量指针
int j=0;
constexpr int i=42;		//i的类型是整型常量
constexpr const int *p=&i;//p是常量指针，指向整形常量i
const int *p1=&j;//p1是常量指针，指向整数
```



## 2.5 处理类型



### 2.5.1 类型别名

传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`

新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）

```cpp
typedef char *pstring;
const pstring cstr=0;	//cstr是指向char的常量指针
const pstring *ps=0;	//ps是一个指针，它的对象是指向char的常量指针
```

**const是对给定类型的修饰，不要尝试把类型别名替换成它本来的样子。**



### 2.5.2 auto类型说明符

**auto**类型说明符：让编译器通过初始值来推算变量的类型，所以定义的变量**必须有初始值**。

```cpp
int i = 0, &r = i; auto a = r; //推断a的类型是int。
```

**auto会忽略顶层const。底层const则会保留下来**

```c++
const int ci=i,&cr=ci;
auto e=&ci;//e是一个指向整数常量的指针

const int ci = 1; const auto f = ci; // 推断类型是int，需要自己加const。
```



### 2.5.3 decltype类型指示符

**动机：**从表达式的类型推断出要定义的变量的类型，但是**不想用该表达式的值初始化变量。**

```cpp
decltype(f()) sum=x;//sum的类型就是函数f的返回类型
```

如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(**包括顶层const和引用在内**)

```c++
const int ci=,&cj=ci;
decltype(ci) x=0;	//x的类型是const int
decltype(cj) y=x;	//y的类型是const int&,y绑定到变量x
decltype(cj) z;		//错误，z是一个引用，必须初始化
```

**decltype和引用**

如果想让结果类型是引用所指的类型，可以**把引用作为表达式的一部分**，结果将是一个具体的值。2.当表达式的内容是解引用操作，则decltype将得到**引用类型。**

```c++
//decltype的结果可以是引用类型
int i=42,*p=&i,&r=i;	
decltype(r+0) b;		//正确：加法的结果是int,因此b是一个(未初始化的)int
decltype(*p) c;			//错误：c是int&,必须初始化
```

**切记：decltype( (variable) ) （注意是双层引号）的结果永远是引用，而decltype( variable ) 结果只有当variable本身就是一个引用时才是引用**

```c++
decltype((i)) d;//错误：di是int&，必须初始化
decltype(i) e;	//正确：e是一个（未初始化的）int
```



## 2.6 自定义数据结构



### 2.6.1 struct

类可以以关键字`struct`开始，紧跟类名和类体。类体右侧的表示结束的花括号后**必须写一个分号。**

类数据成员：类体定义类的成员。

`C++11`：可以为类数据成员提供一个**类内初始值**（in-class initializer）。类内初始值。



### 2.6.2 编写自己的头文件

头文件通常包含哪些只能被定义一次的实体：类、`const`和`constexpr`变量。

预处理器概述：

**预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。

当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`

**#define**指令把一个名字设定为预处理变量，**#ifdef**当且仅当变量已定义时为真，**#ifndef**当且仅当变量未定义时为真。若结果为真，后续操作知道遇到**#endif**指令为止

预处理器变量无视C++语言中关于作用域的规则。

**头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
strct Sale_data{
    ...
}
#endif
```