# 第三章 字符串、向量和数组



## 3.1 using声明

**作用域操作符(::)：**编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字，若左侧为空则在本文件中寻找。

使用某个命名空间（***using namespace::name***）：例如 **using std::cin**表示使用命名空间`std`中的名字`cin`。

头文件中不应该包含`using`声明。因为头文件的内容会拷贝到所有引用它的文件中去。若每个文件都使用相同声明，可能会发生名字冲突。



## 3.2 标准库类型string
标准库类型`string`表示可变长的字符序列。

`#include <string>`，然后 `using std::string;`

**string对象**：注意，不同于字符串字面值。

### 3.2.1 定义和初始化string对象

初始化`string`对象的方式：

| 方式 | 解释 |
| -- | -- |
| `string s1` | 默认初始化，`s1`是个空字符串 |
| `string s2(s1)` | `s2`是`s1`的副本，直接初始化 |
| `string s2 = s1` | 等价于`s2(s1)`，`s2`是`s1`的副本，拷贝初始化 |
| `string s3("value")` | `s3`是字面值“value”的副本，**除了字面值最后的那个空字符外**，直接初始化 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本，拷贝初始化 |
| `string s4(n, 'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串，直接初始化 |

**拷贝初始化（copy initialization）：**使用等号`=`将一个已有的对象拷贝到正在创建的对象。

**直接初始化（direct initialization）：**通过括号给对象赋值。



### 3.2.2 string对象上的操作

`string`的操作：

| 操作 | 解释 |
|-----|-----|
| `os << s` | 将`s`写到输出流`os`当中，返回`os` |
| `is >> s` | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is` |
| etline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
| `s.empty()` | `s`为空返回`true`，否则返回`false` |
| `s.size()` | 返回`s`中字符的个数 |
| `s[n]` | 返回`s`中第`n`个字符的**引用**，位置`n`从0计起 |
| `s1+s2` | 返回`s1`和`s2`连接后的结果 |
| `s1=s2` | 用`s2`的副本代替`s1`中原来的字符 |
| `s1==s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2` | 同上 |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 |

**string IO**

在执行读取操作时，string对象会自动**忽略开头的空白**(即空白符、制表符、换行符等)并从第一个真正的字符开始读起，知道遇到下一个空白为止。

**getline读取一整行**

getline函数第一个参数是**输入流**，第二个参数是**string对象**，从给定的流中读取内容，直到遇到换行符为止(**换行符被读进来了**)，在存入string对象中时**不存入换行符**。

**string::size_type类型**

用于存放string类的size函数返回值的变量，是一个**无符号类型，**可以通过auto和decltype来推导类型。

**提示：如果一条表达式中已经有了size()函数就不要再使用int了，这样就可以避免用int和unsigned可能带来的问题。**

**字面值和string对象相加**

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，**必须确保 + 的两侧至少有一个string。**

**切记：字符串字面值与string是不同的类型。**



### 3.2.3 处理string对象中的字符



**ctype.h vs. cctype**：C++修改了c的标准库，名称为去掉`.h`，前面加`c`。名为cname的头文件从属于命名空间std,而name.h则不然。

`cctype`头文件中定义了一组标准函数：

| 函数 | 解释 |
|-----|-----|
| `isalnum(c)` | 当`c`是字母或数字时为真 |
| `isalpha(c)` | 当`c`是字母时为真 |
| `iscntrl(c)` | 当`c`是控制字符时为真 |
| `isdigit(c)` | 当`c`是数字时为真 |
| `isgraph(c)` | 当`c`不是空格但可以打印时为真 |
| `islower(c)` | 当`c`是小写字母时为真 |
| `isprint(c)` | 当`c`是可打印字符时为真 |
| `ispunct(c)` | 当`c`是标点符号时为真 |
| `isspace(c)` | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)` | 当`c`是大写字母时为真 |
| `isxdigit(c)` | 当`c`是十六进制数字时为真 |
| `tolower(c)` | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c` |
| `toupper(c)` | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c` |

**遍历字符串：**使用**范围for**（range for）语句： `for (auto c: str)`，只能读取字符而不能改变字符。使用 `for (auto &c: str)`使用引用直接改变字符串中的字符。因为操作的是引用就是str中的字符，也可以用 **下标运算符[ ]**接收的参数是string::size_type的值，返回值是**该位置上字符的引用。**



## 3.3 标准库类型vector

- vector是一个**容器**，也是一个类模板；
- `#include <vector>` 然后 `using std::vector;`
- 容器：包含其他对象。
- 类模板：本身不是类或函数，但可以**实例化instantiation**出一个类。看作编译器生成类或函数编写的一份说明。 `vector`是一个模板， `vector<int>`是一个类型。
- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。



### 3.3.1 定义和初始化vector对象

初始化`vector`对象的方法

| 方法 | 解释 |
|-----|-----|
| `vector<T> v1` | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)` | `v2`中包含有`v1`所有元素的副本 |
| `vector<T> v2 = v1` | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本 |
| `vector<T> v3(n, val)` | `v3`包含了n个重复的元素，每个元素的值都是`val` |
| `vector<T> v4(n)` | `v4`包含了n个重复地执行了值初始化的对象 |
| `vector<T> v5{a, b, c...}` | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}` |

**列表初始化：** `vector<string> v{"a", "an", "the"};` （C++11）使用**{ }。**

**创建指定数量的元素：**vector<int> (10,-1);	

**值初始化：**对于不支持默认初始化，只提供数量，无法完成初始化工作。

```cpp
vector<int> ivec(10);//			10个元素，每个都初始化为0
vector<string> ivec(10);//		10个元素，每个都是空string象
```

如果用的是**花括号**，则采用列表初始化。如果使用的是**圆括号**，提供的值是构造对象的。

如果使用花括号形式提供的值无法用来列表初始化，考虑这样的值来构造vector对象。

```cpp
vector<string> v5{"hi"};			//列表初始化：v5有一个元素
vector<string> v6("hi");			//错误：不能使用字符串字面值构建vector对象
vector<string> v7{10};				//v7有10个默认初始化的元素
vector<string> v8{10,"hi"};			//v8有10个值为"hi"的元素
```



### 3.3.2 向vector对象中添加元素

**v.push_back(e)** 在尾部增加元素。

如果循环体内部包含有向vector对象添加元素的语句，则**不能使用范围for循环。**



### 3.3. 其他vector操作

`vector`支持的操作：

| 操作 | 解释 |
|-----|-----|
| `v.emtpy()` | 如果`v`不含有任何元素，返回真；否则返回假 |
| `v.size()` |  返回`v`中元素的个数|
| `v.push_back(t)` | 向`v`的尾端添加一个值为`t`的元素 |
| `v[n]` | 返回`v`中第`n`个位置上元素的**引用** |
| `v1 = v2` | 用`v2`中的元素拷贝替换`v1`中的元素  |
| `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素 |
| `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2` | 同上 |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较 |

范围`for`语句内不应该改变其遍历序列的大小。

**`vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。**



## 3.4 迭代器iterator

- 所有标准库容器都可以使用迭代器。
- 类似于指针类型，迭代器也提供了对对象的间接访问。

### 3.4.1 使用迭代器

`vector<int>::iterator iter`。

`auto b = v.begin();`返回指向第一个元素的迭代器。

`auto e = v.end();`返回指向**最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。不能对其解引用和递增操作。**

如果容器为空， begin 和 end 返回的是同一个迭代器，都是**尾后迭代器。**

**迭代器相等：**1.指向的元素相同。2.都是同一个容器的尾后迭代器。

使用解引用符`*`访问迭代器指向的元素。

养成使用迭代器和`!=`的习惯（泛型编程）。

**容器**：可以包含其他对象；但所有的对象必须类型相同。

**迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。

**const_iterator**：只能读取容器内元素不能改变。

cbegin,cend与begin和end的区别是：不论vector对象本身是否是常量，**返回值都是const_iterator。**即只能读取。

**箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`

**谨记：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。**

标准容器迭代器的运算符:

| 运算符 | 解释 |
|-----|-----|
| `*iter` | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem` | 等价于`(*iter).mem` |
| `++iter` | 令`iter`指示容器中的下一个元素 |
| `--iter` | 令`iter`指示容器中的上一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等 |



### 3.4.2 迭代器运算

`vector`和`string`迭代器支持的运算：

| 运算符 | 解释 |
|-----|-----|
| `iter + n` | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n` | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n` | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1` |
| `iter1 -= n` | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1` |
| `iter1 - iter2` | 两个迭代器相减的结果是**它们之间的距离**，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器**必须指向的是同一个容器中的元素**或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器 |

- **difference_type**：保证足够大以存储任何两个迭代器对象间的距离，可正可负。**带符号类型。**



## 3.5 数组

- 相当于vector的低级版，**长度固定**。

### 3.5.1 定义和初始化内置数组

初始化：`char input_buffer[buffer_size];`，长度必须是常量表达式。

**数组不允许直接赋值给另一个数组。**

**引用不是对象，所以不存在引用的数组。**

像理解数组声明的含义，从数组的名字开始按照由内向外的顺序阅读。

```cpp
int *ptrs[10];
int &refs[10]= /* ? */;		//错误：不存在引用的数组
int (*Parray)[10]=&arr;		//Parray指向一个含有10个整数的数组
int (&arrRef)[10]=arr;		//arrRef引用一个含有10个整数的数组
inr *(&arry)[10]=ptrs;		//arry是数组的引用，该数组含有10个指针		
```



### 3.5.2 访问数组元素

数组下标的类型：`size_t` 。

字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。

**用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。**



### 3.5.3 数组和指针

使用数组时，编译器一般会把它转换成指针。

使用数组作为auto 变量的初始值时，推断得到的类型是指针而非数组。

```cpp
int ia[]={0,1,2,3,4,5,6,7,8,9};
auto ia2(ia)<==> auto ia2(&ia[0]);		//ia2是一个整形指针，指向ia的第一个元素
ia2=42;				//错误：ia2是一个指针，不能用int值给指针赋值
```

使用decltype关键字时上述转化不发生decltype(ia)返回是10个整数构成的数组。

```cpp
decltype(ia) ia3={0,1,2,3,4,5,6,7,8,9};
ia3=p;			//错误：不能用整型指针给数组赋值
ia3[4]=i;		//正确：把i的值分给ia3的一个元素
```

begin(c)和end(c)功能类似于vector的begin()和end()函数。

两个指针相减的结果的类型是一种名为**ptrdiff_t**的标准类型，带符号类型。

**标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。** 

**指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。

## C风格字符串

- 从C继承来的字符串。
- 用空字符结束（`\0`）。
- 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效。
- 获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 。

C标准库String函数，定义在`<cstring>` 中：

| 函数 | 介绍 |
|-----|-----|
| `strlen(p)` | 返回`p`的长度，空字符不计算在内 |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1` |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1` |

## 多维数组

- **多维数组的初始化**： `int ia[3][4] = {{0,1,2,3}, ...}`。
- 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

## 指针vs引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

## 指向指针的指针

- 定义： `int **ppi = &pi;`
- 解引用：`**ppi`

## 动态数组

- 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
- 定义： `int *pia = new int[10];` 10可以被一个变量替代。
- 释放： `delete [] pia;`，注意不要忘记`[]`。





