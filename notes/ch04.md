# 第四章 表达式



## 4.1 表达式基础

**重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。

**运算对象转换：**小整数类型(bool、short、char等)通常会被提升成较大的整数类型，主要是int。

**左值和右值**：

- C中原意：左值**可以**在表达式左边，右值不能。
- `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
- 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。

**求值顺序：**对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一对象，将会引发错误并产生未定义的行为。

**建议：**如果改变了某个运算对象的值，在其他地方不要再使用这个运算对象。



## 4.2 算术运算符

**溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。很多系统再编译和运行时都不报溢出错误。

**在C++11中：m%n的符号与m相同。**

## 4.3 逻辑运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。

## 4.4 赋值运算符

- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足右结合律，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- **赋值运算优先级比较低。**
- 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。
- 赋值运算符的左侧运算对象必须是一个**可修改的左值**。



## 4.5递增和递减运算符

**前置递增：**首先将运算对象加一，返回将改变后的对象作为求值结果。返回的是一个左值。

**后置递增：**首先将运算对象加一，返回将改变前的对象作为求值结果。返回的是一个右值。

**运算对象可按任意顺序求值：**如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，复合表达式中要提防运用递增和递减运算符。

```cpp
while(beg!=s.end()&&!isspace(*beg)){
    *beg=toupper(*beg++);			//错误：该赋值语句未定义
}
```



## 4.6 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

## 4.7 位运算符

- 位运算符是作用于**整数类型**的运算对象。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）、与（`&`）、或（`|`）、异或（`^`）
- 如果运算对象是"小整型"，则它的值会被自动提升。
- **算术运算符>移位运算符>关系运算符。**



## 4.9 sizeof运算符

- 返回一条表达式或一个类型名字所占的**字节数**。返回的类型是 `size_t`**的常量表达式**。
- 两种形式： `sizeof (type)`和 `sizeof expr`
- **sizeof运算不会把数组转换成指针来处理。**
- 逗号运算符：按照**从左向右**的顺序依次求值。**其优先级最低。**



## 4.11 类型转换

### 4.11.2 隐式类型转换

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时。
- 数组转化成指针。当数组被用作decltype关键字参数、或者取地址符、sizeof及typeid等运算符的运算对象时，上述转换不会发生。



### 4.11.3 显式类型转换（尽量避免）

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`
- **dynamic_cast**：支持运行时类型识别。
- **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`
- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。
